# srm
Simple Register Model for uvm testbenches. 

## Overview
A register model (or register abstraction layer) is a model of the software visible registers and memories in the design. The model, implemented as system verilog classes, makes the job of stimulus generation, functional checking and functional coverage easier for the test writer. 

Currently the uvm verification methodology ships with the uvm_register package (uvm_reg) that can be used to model these registers and memories in the design. However this framework is heavyweight and has a complex API for the test writer to master. With the current System On Chip (SoC) chips having tens of thousand registers and embedded memories, the framework adds a signficant load and build time performance penalty to the testbench. 

Hence a need for developing a new simple register model framework (srm) that is light weight and yet has all the flexibility required by the test writer. The new framework fits seamlessly with both UVM or a legacy non UVM environment. Using srm, it is possible to generate register model faster and write test sequences that are more reusable across different hierarchy of testbenches (like block, sub system, system level). Sequences remain independent of the access mechanism like frontdoor, backdoor etc. and so can run unchanged on different types of design like RTL, gates etc.

## Test bench setup
### Active Operation
In active operation the register access are sourced by the register model via the access api. These *read* and *write* operations on the register model are converted to generic bus transactions by the model. These are then forwarded to the selected bus adapter as per the configured adapter policy. The selected bus adapter implements the actual conversion from the generic transaction to the actual bus transaction. 

For example the backdoor adapter may just use dpi to directly set/get the design flops. A frontdoor adapter would run the actual bus transaction to implement the transfer.

![Active Operation](docs/images/srm_reg_active.png)


### Passive Operation
For passive operation the register access is not generated by the register model. This could be generated by some other mechanism like embedded sofware, or a legacy non UVM environment but the model is still required to be accurate for the checks and functional coverage.

In this case a predictor is used to observe the bus transactions and then forward them to the srm register model.

![Passive Operation](docs/images/srm_reg_passive.png)


## Major Issues 

### Heavyweight Memory Usage 
Below is the performance of a modern simulator on a simple design consisting of just a register. As we increase the number of registers in the design, the memory footprint increases linearly. 
It is well known that generally most of the tests do not access all the possible address locations. Hence it is expensive to pay this price for all tests.
One of the common reasons that this happens is that uvm_reg does not natively model array of registers. Hence the register model has to use a static array to model it. This causes the memory footprint to grow and does not scale for large arrays. Randomizing this static array is also not possible beyond some trivial depth.

For large tables or external memories, uvm_reg does provide the *uvm_vreg* class for modelling it. However the uvm_vreg class does not have any storage and is only an access api. The testwriter has to implement all the burden of funcitonal checking and coverage. Moreover the api is different and so generic sequences written for uvm_reg cannot be reused on uvm_vreg.

srm fixes the problem by creating a sparse memory model for register array. None of the entries are allocated till the entry is actually written. 

### Non Intuitive Access API
uvm_reg adds the random constraints and the selection of the bus adapter to use as part of the register model acess api. This makes the api confusing and unnecessarily complicated. For supporting constraint randomization it adds the *mirror* and *update* routine. For supporting backdoor access it has the *peek* and *poke* routine. Hence it provides a confusing mix of routines with hard to grasp semantics.

Sequences for register model access are intuitively similar to real world software programming. Hence the access api should be similar to the basic *read*, *write* api of the software land. It is possible to add this extra testbench specific requirements without cluttering the access api. 

srm solves the above problem by separating out these concerns from the access api. These are discussed below.
#### Constraint Random Stimulus
The constraints on the fields of the register are modelled as separate constraint classes in srm. These can be organized independent of the actual register model.

#### Bus Adapter Policy
srm cleanly separates out the policy of selecting the bus adapter to use for the register access from the access api. A register can be accessed by any number of bus adapters like frontdoor or backdoor. The policy can be selected depending on the context it was spawned. For example if a sequence is spawned as part of configuration sequence, it could use the backdoor bus adapter for simulation speedup. If run as part of background pio access, it should always use the frontdoor access policy even if the backdoor was available.


## References
[Non Intuitive API][http://agilesoc.com/2014/03/09/youre-either-with-me-or-youre-with-the-uvm-register-package/]
[HeavyWeight][http://www.verilab.com/files/litterick_register_final_1.pdf]
